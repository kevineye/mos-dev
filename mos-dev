#!/usr/bin/perl

package MOSDev;
use autodie qw(:all);
use Moo;
use MooX::Cmd;
use MooX::Options;
use YAML ();
use JSON ();
use Term::ANSIColor;

option port => (
    is     => 'lazy',
    format => 's',
    doc    => 'port to connect to device (/dev/tty..., ws://.../rpc)',
    short  => 'p',
  );
sub _build_port {
  return shift->config->{port} || '';
}

option mos_cli => (
    is      => 'rw',
    format => 's',
    default => 'mos',
    short   => 'mos-cli',
    doc     => 'path to `mos` binary',
  );

option 'config_dir' => (
    is      => 'rw',
    default => './.mos-dev',
    short   => 'config-dir',
    doc     => 'directory of mos-dev.yml config file',
  );

sub config_file {
  return shift->config_dir . '/mos-dev.yml';
}

has config => (
    is => 'lazy'
  );
sub _build_config {
  my $self = shift;
  return {} unless -e $self->config_file;
  return YAML::LoadFile($self->config_file);
}

sub execute {
  my ($self, $args_ref) = @_;
  $self->options_usage;
}

sub save_port {
  my ($self, $port) = @_;
  $self->config->{port} = $port;
  $self->save_config;
}

sub save_config {
  my ($self) = shift;
  mkdir $self->config_dir unless -d $self->config_dir;
  local $YAML::Stringify = 1;
  local $YAML::UseHeader = 0;
  YAML::DumpFile($self->config_file, $self->config);
}

sub call {
  my ($self, $cmd, $args) = @_;
  my $port = $self->port;
  $self->save_port($port);

  my $c = $self->console_stop;

  my $pid = open my $pipe, '-|';
  if ($pid == 0) {
    exec $self->mos_cli, '--port', $port, 'call', $cmd, JSON->new->allow_nonref->encode($args || {});
  }
  else {
    my @output = <$pipe>;
    close $pipe;
    my $o = eval {JSON->new->allow_nonref->decode(join '', @output)};
    if ($@) {
      die @output;
    }
    else {
      $self->console_start if $c;
      return $o;
    }
  }
}

sub console_start {
  my ($self, $wait) = @_;
  return if $self->{console_pid};
  $self->{console_pid} = fork;
  if ($self->{console_pid} == 0) {
    exec $self->mos_cli, '--port', $self->port, 'console';
  }
  else {
    waitpid $self->{console_pid}, 0 if $wait;
  }
}

sub console_stop {
  my ($self) = @_;
  my $ret = 0;
  if ($self->{console_pid}) {
    kill 'TERM', $self->{console_pid};
    $ret = 1;
  }
  $self->{console_pid} = undef;
  return $ret;
}

sub build {
  my ($self, $arch, $wait) = @_;
  unless ($arch) {
    my $info = $self->call('Sys.GetInfo');
    $arch = $info->{arch};
  }
  die "Cannot determine architecture." unless $arch;

  my $pid = fork;
  if ($pid == 0) {
    exec $self->mos_cli, 'build', '--platform', $arch, '--local';
  }
  else {
    waitpid $pid, 0 if $wait;
  }
}

sub status {
  my $self = shift;
  my $info = $self->call('Sys.GetInfo');

  my $gy = color('bright_black');
  my $bk = color('black');
  my $gn = color('green');
  my $bl = color('blue');
  my $mg = color('magenta');

  printf "${gy}Port:   ${gn}%s\n", $self->port;
  printf "${gy}Uptime: ${mg}%s seconds\n", $info->{uptime};
  printf "${gy}Chip:   ${gy}%s\n", $info->{arch};
  printf "${gy}App:    ${bl}%s %s ${gy}(build %s)\n", $info->{app}, $info->{fw_version}, $info->{fw_id};
  printf "${gy}FS:     ${bk}%s free ${gy}of %s\n", $info->{fs_free}, $info->{fs_size};
  printf "${gy}RAM:    ${bk}%s free ${gy}of %s (%s min free)\n", $info->{ram_free}, $info->{ram_size},
    $info->{ram_min_free};
  printf "${gy}MAC:    ${gy}%s\n", $info->{mac} =~ s{(..)(..)(..)(..)(..)(..)}{$1:$2:$3:$4:$5:$6}r;
  printf "${gy}WiFi:   %s%s\n", ($info->{wifi}{status} =~ /connected|got ip/ ? $gn : $gy),
    ($info->{wifi}{sta_ip} ? "$info->{wifi}{sta_ip} on $info->{wifi}{ssid}" : $info->{wifi}{ap_ip} || $info->{wifi}{status});
  print $bk;
}

package MOSDev::Cmd::Connect;
use autodie qw(:all);
use Moo;
use MooX::Cmd;
use MooX::Options;

sub execute {
  my ($self, $args_ref, $chain_ref) = @_;
  my $mosdev = $chain_ref->[0];
  my $port = $args_ref->[0] || $mosdev->port;
  $mosdev->save_port($port);
  $mosdev->status;
}


package MOSDev::Cmd::Sync;
use autodie qw(:all);
use Moo;
use MooX::Cmd;
use MooX::Options;
use Cwd 'abs_path';
use Filesys::Notify::Simple;
use Term::ANSIColor;
use Time::CTime;
use Time::HiRes;

sub _download_config {
  my ($self, $mosdev, $device_config) = @_;
  my $port = $mosdev->port;
  my $cmd = sprintf '"%s" --port "%s" config-get', $mosdev->mos_cli, $port;
  my $out = qx{$cmd};
  if ($out =~ /^{/) {
    open my $fh, '>', $device_config;
    $fh->print($out);
    $fh->close;
  }
  else {
    die "Connect to device at $port failed.\n";
  }
}

sub log {
  my ($self, $message) = @_;
  printf "%s[%s] > %s%s\n", color('bright_black'), strftime('%b %d %T.000', localtime), $message, color('black');
}

sub execute {
  my ($self, $args_ref, $chain_ref) = @_;
  my $mosdev = $chain_ref->[0];

  my $port = $mosdev->port;
  $mosdev->save_port($port);
  $mosdev->status;
  print "\n";

  my $device_config = abs_path $mosdev->config_dir . "/config.json";
  $self->_download_config($mosdev, $device_config);
  $self->log("Downloaded config -> .mos-dev/config.json");

  my $reboot_file = abs_path $mosdev->config_dir . "/reboot";
  unless (-e $reboot_file) {
    open my $fh, '>', $reboot_file;
    $fh->close;
  }

  my $build_file = abs_path $mosdev->config_dir . "/build";
  unless (-e $build_file) {
    open my $fh, '>', $build_file;
    $fh->close;
  }

  $mosdev->console_start;

  my $watcher = Filesys::Notify::Simple->new([ '.' ]);
  my $cwd = abs_path '.';
  my $skip_next_config_event = 0;
  while (1) {
    $watcher->wait(sub {
      for my $event (@_) {
        if ($event->{path} eq $reboot_file) {
          $mosdev->console_stop;
          $self->log("Reboot file touched, rebooting device");
          $mosdev->call('Sys.Reboot');
          $mosdev->console_start;
        }
        elsif ($event->{path} eq $device_config) {
          if ($skip_next_config_event == 0) {
            $mosdev->console_stop;
            if (-f $event->{path}) {
              $self->log("Uploading .mos-dev/config.json");
              open my $fh, '<', $device_config;
              my $c = JSON->new->allow_nonref->decode(join '', <$fh>);
              $fh->close;
              $mosdev->call('Config.Set', { config => $c });
              $mosdev->call('Config.Save', { reboot => JSON::false });
              $self->_download_config($mosdev, $device_config);
              $skip_next_config_event++;
              $self->log("Downloaded config -> .mos-dev/config.json");
              $self->log("Rebooting device");
              $mosdev->call('Sys.Reboot');
            }
            else {
              $self->_download_config($mosdev, $device_config);
              $skip_next_config_event++;
              $self->log("Downloaded config -> .mos-dev/config.json");
            }
            $mosdev->console_start;
          }
          else {
            $skip_next_config_event--;
          }
        }
        elsif ($event->{path} =~ qr{^$cwd/(fs/.*)}) {
          $mosdev->console_stop;
          if (-f $event->{path}) {
            $self->log("Uploading file $1");
            system $mosdev->mos_cli, '--port', $port, 'put', $event->{path};
          }
          else {
            $self->log("Removing file $1");
            my $f = $event->{path};
            $f =~ s{.*/}{};
            system $mosdev->mos_cli, '--port', $port, 'rm', $f;
          }
          $mosdev->console_start;
        }
        elsif ($event->{path} eq "$cwd/build/fw.zip") {
          if (-f $event->{path}) {
            $mosdev->console_stop;
            $self->log("Flashing firmware build/fw.zip");
            system $mosdev->mos_cli, '--port', $port, 'flash', $event->{path};
            $mosdev->console_start;
          }
        }
        elsif ($event->{path} eq $build_file) {
          $self->log("Build file touched, building firmware...");
          $mosdev->build(0);
        }
      }
    });
  }
}

package MOSDev::Cmd::Reboot;
use autodie qw(:all);
use Moo;
use MooX::Cmd;
use MooX::Options;

sub execute {
  my ($self, $args_ref, $chain_ref) = @_;
  my $mosdev = $chain_ref->[0];
  $mosdev->call('Sys.Reboot');
}


package MOSDev::Cmd::Build;
use autodie qw(:all);
use Moo;
use MooX::Cmd;
use MooX::Options;

option arch => (
    is     => 'rw',
    format => 's',
    doc    => 'architecture to build for, check connected device if not set',
  );

sub execute {
  my ($self, $args_ref, $chain_ref) = @_;
  my $mosdev = $chain_ref->[0];
  $mosdev->build($self->arch, 1);
}


package MOSDev::Cmd::Console;
use autodie qw(:all);
use Moo;
use MooX::Cmd;
use MooX::Options;

sub execute {
  my ($self, $args_ref, $chain_ref) = @_;
  my $mosdev = $chain_ref->[0];
  $mosdev->console_start(1);
}


package main;
MOSDev->new_with_cmd unless caller;

1;
