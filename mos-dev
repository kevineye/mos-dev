#!/usr/bin/perl

package MOSDev;

use autodie qw(:all);
use Moo;

use CLI::Osprey abbreviate => 0;
use Cwd 'abs_path';
use Filesys::Notify::Simple;
use IO::Interface::Simple;
use IO::Socket::INET;
use JSON ();
use Term::ANSIColor 'color';
use Time::CTime 'strftime';
use Time::HiRes;
use YAML ();

option port => (
    is         => 'lazy',
    format     => 's',
    format_doc => 'port',
    doc        => 'port to connect to device (/dev/tty..., ws://.../rpc)',
    short      => 'p',
  );
sub _build_port {
  return shift->config->{port} || '';
}

option mos_cli => (
    is         => 'rw',
    format     => 's',
    format_doc => 'path',
    default    => 'mos',
    doc        => 'path to `mos` binary',
  );

option 'config_dir' => (
    is         => 'rw',
    format     => 's',
    format_doc => 'path',
    default    => './.mos-dev',
    doc        => 'directory of mos-dev.yml config file',
  );

sub config_file {
  return shift->config_dir . '/mos-dev.yml';
}

has config => (
    is => 'lazy'
  );
sub _build_config {
  my $self = shift;
  return {} unless -e $self->config_file;
  return YAML::LoadFile($self->config_file);
}

sub run {
  my ($self) = @_;
  $self->osprey_usage(- 1);
}

sub save_port {
  my ($self, $port) = @_;
  $self->config->{port} = $port;
  $self->save_config;
}

sub save_config {
  my ($self) = shift;
  mkdir $self->config_dir unless -d $self->config_dir;
  local $YAML::Stringify = 1;
  local $YAML::UseHeader = 0;
  YAML::DumpFile($self->config_file, $self->config);
}

sub call {
  my ($self, $cmd, $args, $rawout) = @_;
  my $port = $self->port;
  $self->save_port($port);

  my $c = $self->console_stop;

  $args = JSON->new->allow_nonref->encode($args) if ref $args;
  $args ||= '{}';

  my $pid = open my $pipe, '-|';
  if ($pid == 0) {
    exec $self->mos_cli, '--port', $port, 'call', $cmd, $args;
  }
  else {
    my @output = <$pipe>;
    close $pipe;
    my $o;
    if ($rawout) {
      $o = join '', @output;
    } else {
      $o = eval {JSON->new->allow_nonref->decode(join '', @output)};
      die @output if $@;
    }
    $self->console_start if $c;
    return $o;
  }
}

sub port_type {
  my $port = shift->port;
  return $port =~ m{^ws://} ? 'ws' : 'dev';
}

sub console_start {
  my $self = shift;
  my $method = 'console_start_' . $self->port_type;
  $self->$method(@_);
}

sub console_stop {
  my $self = shift;
  my $method = 'console_stop_' . $self->port_type;
  $self->$method(@_);
}

option 'udp_log_addr' => (
    is         => 'lazy',
    format     => 's',
    format_doc => 'host:port',
    doc        => 'listening/sending address for UDP logging',
  );
sub _build_udp_log_addr {
  my $port = '10001';
  for my $name (qw(eth0 en0)) {
    my $if = IO::Interface::Simple->new($name);
    next unless $if;
    my $addr = $if->address;
    return "$addr:$port" if $addr;
  }
  for my $i (0..10) {
    my $if = IO::Interface::Simple->new_from_index($i);
    next unless $if;
    my $addr = $if->address;
    return "$addr:$port" if $addr;
  }
  return "127.0.0.1:$port";
}

sub console_start_ws {
  my ($self, $wait) = @_;
  return if $self->{console_pid};

  my $addr = $self->udp_log_addr;
  my (undef, $port) = split ':', $addr;
  $self->log("Starting UDP log listener on port $port");
  $self->{console_pid} = fork;
  if ($self->{console_pid} == 0) {
    #exec 'nc', '-u', '-l', '-k', '-d', $port;
    while (1) {
      my $sock = IO::Socket::INET->new(LocalPort => $port, Proto => 'udp') or die "$@\n";
      my $msg;
      print $msg while $sock->recv($msg, 1024);
      $sock->close;
      warn "UDP socket closed, reopening...\n";
    }
    exit;
  }
  else {
    $self->log("Configuring UDP log sending to $addr");
    system $self->mos_cli, '--port', $self->port, '--no-reboot', 'config-set', "debug.udp_log_addr=$addr";
    waitpid $self->{console_pid}, 0 if $wait;
  }
}

sub console_stop_ws {}

sub console_start_dev {
  my ($self, $wait) = @_;
  return if $self->{console_pid};
  $self->{console_pid} = fork;
  if ($self->{console_pid} == 0) {
    exec $self->mos_cli, '--port', $self->port, 'console';
  }
  else {
    waitpid $self->{console_pid}, 0 if $wait;
  }
}

sub console_stop_dev {
  my ($self) = @_;
  my $ret = 0;
  if ($self->{console_pid}) {
    kill 'TERM', $self->{console_pid};
    $ret = 1;
  }
  $self->{console_pid} = undef;
  return $ret;
}

sub build {
  my ($self, $arch, $wait) = @_;
  unless ($arch) {
    my $info = $self->call('Sys.GetInfo');
    $arch = $info->{arch};
  }
  die "Cannot determine architecture." unless $arch;

  my $pid = fork;
  if ($pid == 0) {
    exec $self->mos_cli, 'build', '--platform', $arch, '--local';
  }
  else {
    waitpid $pid, 0 if $wait;
  }
}

sub status {
  my $self = shift;
  my $info = $self->call('Sys.GetInfo');

  my $gy = color('bright_black');
  my $bk = color('black');
  my $gn = color('green');
  my $bl = color('blue');
  my $mg = color('magenta');

  printf "${gy}Port:   ${gn}%s\n", $self->port;
  printf "${gy}Uptime: ${mg}%s seconds\n", $info->{uptime};
  printf "${gy}Chip:   ${gy}%s\n", $info->{arch};
  printf "${gy}App:    ${bl}%s %s ${gy}(build %s)\n", $info->{app}, $info->{fw_version}, $info->{fw_id};
  printf "${gy}FS:     ${bk}%s free ${gy}of %s\n", $info->{fs_free}, $info->{fs_size};
  printf "${gy}RAM:    ${bk}%s free ${gy}of %s (%s min free)\n", $info->{ram_free}, $info->{ram_size},
    $info->{ram_min_free};
  printf "${gy}MAC:    ${gy}%s\n", $info->{mac} =~ s{(..)(..)(..)(..)(..)(..)}{$1:$2:$3:$4:$5:$6}r;
  printf "${gy}WiFi:   %s%s\n", ($info->{wifi}{status} =~ /connected|got ip/ ? $gn : $gy),
    ($info->{wifi}{sta_ip} ? "$info->{wifi}{sta_ip} on $info->{wifi}{ssid}" : $info->{wifi}{ap_ip} || $info->{wifi}{status});
  print color('reset');
}

subcommand connect => sub {
    my $self = shift;
    my $port = $_[0] || $self->port;
    $self->save_port($port);
    $self->status;
  };

sub _download_config {
  my ($self, $device_config) = @_;
  my $port = $self->port;
  my $cmd = sprintf '"%s" --port "%s" config-get', $self->mos_cli, $port;
  my $out = qx{$cmd};
  if ($out =~ /^{/) {
    open my $fh, '>', $device_config;
    $fh->print($out);
    $fh->close;
  }
  else {
    die "Connect to device at $port failed.\n";
  }
}

sub log {
  my ($self, $message) = @_;
  printf "%s[%s] > %s%s\n", color('bright_black'), strftime('%b %d %T.000', localtime), $message, color('reset');
}

subcommand sync => sub {
    my ($self) = @_;

    my $port = $self->port;
    $self->save_port($port);
    $self->status;
    print "\n";

    $self->console_start;

    my $device_config = abs_path $self->config_dir . "/config.json";
    $self->_download_config($device_config);
    $self->log("Downloaded config -> .mos-dev/config.json");

    my $reboot_file = abs_path $self->config_dir . "/reboot";
    unless (-e $reboot_file) {
      open my $fh, '>', $reboot_file;
      $fh->close;
    }

    my $build_file = abs_path $self->config_dir . "/build";
    unless (-e $build_file) {
      open my $fh, '>', $build_file;
      $fh->close;
    }

    my $watcher = Filesys::Notify::Simple->new([ '.' ]);
    my $cwd = abs_path '.';
    my $skip_next_config_event = 0;
    while (1) {
      $watcher->wait(sub {
        for my $event (@_) {
          if ($event->{path} eq $reboot_file) {
            $self->console_stop;
            $self->log("Reboot file touched, rebooting device");
            $self->call('Sys.Reboot');
            $self->console_start;
          }
          elsif ($event->{path} eq $device_config) {
            if ($skip_next_config_event == 0) {
              $self->console_stop;
              if (-f $event->{path}) {
                $self->log("Uploading .mos-dev/config.json");
                open my $fh, '<', $device_config;
                my $c = JSON->new->allow_nonref->decode(join '', <$fh>);
                $fh->close;
                $self->call('Config.Set', { config => $c });
                $self->call('Config.Save', { reboot => JSON::false });
                $self->_download_config($device_config);
                $skip_next_config_event++;
                $self->log("Downloaded config -> .mos-dev/config.json");
                $self->log("Rebooting device");
                $self->call('Sys.Reboot');
              }
              else {
                $self->_download_config($device_config);
                $skip_next_config_event++;
                $self->log("Downloaded config -> .mos-dev/config.json");
              }
              $self->console_start;
            }
            else {
              $skip_next_config_event--;
            }
          }
          elsif ($event->{path} =~ qr{^$cwd/(fs/.*)}) {
            $self->console_stop;
            if (-f $event->{path}) {
              $self->log("Uploading file $1");
              system $self->mos_cli, '--port', $port, 'put', $event->{path};
            }
            else {
              $self->log("Removing file $1");
              my $f = $event->{path};
              $f =~ s{.*/}{};
              system $self->mos_cli, '--port', $port, 'rm', $f;
            }
            $self->console_start;
          }
          elsif ($event->{path} eq "$cwd/build/fw.zip") {
            if (-f $event->{path}) {
              $self->console_stop;
              $self->log("Flashing firmware build/fw.zip");
              $self->flash($event->{path});
              $self->console_start;
            }
          }
          elsif ($event->{path} eq $build_file) {
            $self->log("Build file touched, building firmware...");
            $self->build(0);
          }
        }
      });
    }

  };

sub flash {
  my ($self, $path) = @_;
  $path ||= 'build/fw.zip';
  die "firmware file $path does not exist\n" unless -e $path;
  my $c = $self->console_stop;
  system $self->mos_cli, '--port', $self->port, 'flash', $path;
  $self->console_start if $c;
}

subcommand reboot => sub {shift->call('Sys.Reboot')};
subcommand console => sub {shift->console_start(1)};
subcommand flash => sub {shift->flash(@_)};
subcommand call => sub {print $_[0]->call($_[1] || 'RPC.List', $_[2], 1)};
subcommand help => sub {shift->osprey_help};

subcommand build => 'MOSDev::Build';

package MOSDev::Build;
use Moo;
use CLI::Osprey desc => 'foobar';

option arch => (
    is         => 'rw',
    format     => 's',
    format_doc => 'arch',
    doc => 'architecture to build for, check connected device if not set',
  );

sub run {
  my ($self) = @_;
  $self->parent_command->build($self->arch, 1);
}


package main;
MOSDev->new_with_options->run unless caller;

1;
